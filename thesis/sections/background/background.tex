\documentclass[../../main]{subfiles}
\begin{document}

In this chapter, the main intention is to give the reader an initial knowledge base on all the theoretical concepts and all the components that had been utilized in the development of this research.

\dots spiegazione per sezione \dots

\section{Constraint Programming}
Constraint programming (CP) is an emergent software technology for declarative description and effective solving of large, particularly combinatorial, problems especially in areas of planning and scheduling~\cite{CPholygrail}.

A constraint can be thought of intuitively as a formalization of dependencies in physical worlds and their mathematical abstractions. A constraint is a logical relation among several unknowns (or variables), each taking a value in a given domain. The constraint thus restricts the possible values that variables can take; it represents partial information about the variables of interest. Constraints can also be heterogeneous, so they can bind unknowns from different domains, for example a length (number) with a word (string). The important feature of constraints is their declarative manner, i.e., they specify what relationship must hold without specifying a computational procedure to enforce that relationship~\cite{CPholygrail}.

Constraints arise naturally in most areas of human endeavor. They are the natural medium of expression for formalizing regularities that underlie the computational and (natural or designed) physical worlds and their mathematical abstractions. 

Constraint programming is the study of computational systems based on constraints. The idea of constraint programming is to solve problems by stating constraints (requirements) about the problem area and, consequently, finding a solution satisfying all the constraints.

As stated by E. C. Freuder thirty years ago,``Constraint Programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it.''~\cite{holygrail}.

\subsection{CP Solvers}
In the courses of this research paper, we will often talk about ``Solvers''.
A CP solver is defined as a system or program that manipulates constraints to find solutions that satisfy specified conditions. It can utilize various approaches to enhance flexibility and customization within specific constraint domains, particularly finite domains.

So, given that a CP model is a tuple $\langle X, D, C, O \rangle$ where $X$ is the set of variables we are trying to assign a value to, $D(x)$ is the domain associated with each variable, $C$ is the set of constraints that the variables must respect, and $O$ is an objective function, the goal of the solver is to assign a value for each variable $x \in X$ from $D(x)$ that satisfies all the constraints in $C$ and optimizes the objective function $O$~\cite{SeaPearl}.

\subsubsection{Portfolio Solvers}
Solving combinatorial search problems is hard, and there exist nowadays plenty of techniques and constraint solvers for performing this task. It has become clear that different solvers are better when solving different problem instances, even within the same problem class. It has also been shown that a single, arbitrarily efficient solver can be significantly outperformed by using a portfolio of possibly on-average slower solvers~\cite{PortfolioSolvers}.

Algorithm portfolios~\cite{AlgPortfolio} can be seen as instances of the more general Algorithm Selection problem~\cite{AlgSelProb} where, as reported in~\cite{AlgSelCSP}, the algorithm selection is performed case-by-case for each problem to solve. Within the context of constraint solving, a portfolio approach enables to combine a number $m > 1$ of different constituent solvers $s_1, \dots, s_m$ in order to create a globally better constraint solver, dubbed a portfolio solver. When a new, unseen problem $p$ comes, the portfolio solver tries to predict the best constituent solver(s) $s_{i_1}, \dots, s_{i_k}$ (with $1 \leq i_j \leq m$ for $j = 1, \dots, k$) for solving $p$ and then runs them on $p$. Properly selecting and scheduling the solvers is a crucial step for the performance of a portfolio solver, and it is usually performed by exploiting Machine Learning techniques based on features extracted from the problem $p$ to solve.

In the course of this research paper, starting from the idea behind portfolio solvers, we will try to evaluate the performances of an agentic solver that uses pre-trained large language model as its agent to understand if this could be a viable solution to the algorithm selection problem~\cite{AlgSelProb}, following the new paradigm proposed in ~\cite{fromPFStoAS}.

\subsection{MiniZinc}
MiniZinc is a simple but expressive CP modelling language which is suitable for modelling problems for a range of solvers and a reasonable compromise between many design possibilities.

Born from the necessity of a standard modelling language for constraint programming problems also making solver benchmarking simpler~\cite{MiniZinc}.

For these reasons all of the problems employed for testing in the course of this research paper were written using MiniZinc.

\subsubsection{Specifying a Problem}
A MiniZinc problem specification has two parts: (a) the model, which describes
the structure of a class of problems; and (b) the data, which specifies one particular problem within this class. The pairing of a model with a particular data set is a model instance (sometimes abbreviated to instance).

The model and data may be in separate files. Data files can only contain assignments to parameters declared in the model. A user specifies data files on the command line, rather than naming them in the model file, so that the model file is not tied to any particular data file~\cite{MiniZinc}.

\subsubsection{MiniZinc Challenge}
Comparing constraint programming systems is fraught with difficulty and in reality an impossible task. The reason is that there are so many components to a modern CP system, only some of which are implemented by some systems. To claim that one CP system is ``better'' than another is a bold claim, since there is almost certainly some problem for which the ``worse'' system allows a stronger model, or a better search, and performs better.


\end{document}